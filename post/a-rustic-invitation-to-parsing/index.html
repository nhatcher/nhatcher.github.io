<!doctype html><html dir=ltr lang=en data-theme class="html theme--light"><head>
<title>
Nicolás Hatcher
|
A Rustic invitation to parsing
</title>
<meta charset=utf-8><meta name=generator content="Hugo 0.122.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name=author content="Nicolás Hatcher">
<meta name=description content="Software developer by trade, physicist by soul">
<link rel=stylesheet href=/scss/main.min.1147aa5bacb4bce677a0e264073829caedb82fd18ea07a5f1d80521f539d1c45.css integrity="sha256-EUeqW6y0vOZ3oOJkBzgpyu24L9GOoHpfHYBSH1OdHEU=" crossorigin=anonymous type=text/css>
<link rel=stylesheet href=/css/markupHighlight.min.73ccfdf28df555e11009c13c20ced067af3cb021504cba43644c705930428b00.css integrity="sha256-c8z98o31VeEQCcE8IM7QZ688sCFQTLpDZExwWTBCiwA=" crossorigin=anonymous type=text/css>
<link rel=stylesheet href=/fontawesome/css/fontawesome.min.7d272de35b410fb165377550cdf9c4d3a80fbbcc961e111914e4d5c0eaf5729f.css integrity="sha256-fSct41tBD7FlN3VQzfnE06gPu8yWHhEZFOTVwOr1cp8=" crossorigin=anonymous type=text/css>
<link rel=stylesheet href=/fontawesome/css/solid.min.55d8333481b07a08e07cf6f37319753a2b47e99f4c395394c5747b48b495aa9b.css integrity="sha256-VdgzNIGwegjgfPbzcxl1OitH6Z9MOVOUxXR7SLSVqps=" crossorigin=anonymous type=text/css>
<link rel=stylesheet href=/fontawesome/css/regular.min.a7448d02590b43449364b6b5922ed9af5410abb4de4238412a830316dedb850b.css integrity="sha256-p0SNAlkLQ0STZLa1ki7Zr1QQq7TeQjhBKoMDFt7bhQs=" crossorigin=anonymous type=text/css>
<link rel=stylesheet href=/fontawesome/css/brands.min.9ed75a5d670c953fe4df935937674b4646f92674367e9e66eb995bb04e821647.css integrity="sha256-ntdaXWcMlT/k35NZN2dLRkb5JnQ2fp5m65lbsE6CFkc=" crossorigin=anonymous type=text/css>
<link rel="shortcut icon" href=/favicons/favicon.ico type=image/x-icon>
<link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png>
<link rel=canonical href=https://www.nhatcher.com/post/a-rustic-invitation-to-parsing/>
<script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.d6d329d93844b162e8bed1e915619625ca91687952177552b9b3e211014a2957.js integrity="sha256-1tMp2ThEsWLovtHpFWGWJcqRaHlSF3VSubPiEQFKKVc=" crossorigin=anonymous></script>
<meta name=twitter:card content="summary"><meta name=twitter:title content="A Rustic invitation to parsing">
<meta name=twitter:description content="(A version of this post appeared first in the EqualTo blog)">
<meta property="og:title" content="A Rustic invitation to parsing">
<meta property="og:description" content="(A version of this post appeared first in the EqualTo blog)">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.nhatcher.com/post/a-rustic-invitation-to-parsing/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2023-04-20T11:08:43+02:00">
<meta property="article:modified_time" content="2023-04-20T11:08:43+02:00"><meta property="og:site_name" content="I'm Nicolás Hatcher">
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"post","name":"A Rustic invitation to parsing","headline":"A Rustic invitation to parsing","alternativeHeadline":"","description":"
      
        (A version of this post appeared first in the EqualTo blog)


      


    ","inLanguage":"en","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.nhatcher.com\/post\/a-rustic-invitation-to-parsing\/"},"author":{"@type":"Person","name":"Nicolás Hatcher"},"creator":{"@type":"Person","name":"Nicolás Hatcher"},"accountablePerson":{"@type":"Person","name":"Nicolás Hatcher"},"copyrightHolder":{"@type":"Person","name":"Nicolás Hatcher"},"copyrightYear":"2023","dateCreated":"2023-04-20T11:08:43.00Z","datePublished":"2023-04-20T11:08:43.00Z","dateModified":"2023-04-20T11:08:43.00Z","publisher":{"@type":"Organization","name":"Nicolás Hatcher","url":"https://www.nhatcher.com","logo":{"@type":"ImageObject","url":"https:\/\/www.nhatcher.com\/favicons\/favicon-32x32.png","width":"32","height":"32"}},"image":[],"url":"https:\/\/www.nhatcher.com\/post\/a-rustic-invitation-to-parsing\/","wordCount":"3091","genre":[],"keywords":[]}</script>
</head>
<body class=body>
<div class=wrapper>
<aside class=wrapper__sidebar><div class="sidebar
.">
<div class=sidebar__content>
<div class=sidebar__introduction>
<img class=sidebar__introduction-profileimage src=/images/profile.jpg alt="profile picture">
<div class=sidebar__introduction-title>
<a href=/>I'm Nicolás Hatcher</a>
</div>
<div class=sidebar__introduction-description>
<p>Software developer by trade, physicist by soul</p>
</div>
</div>
<ul class=sidebar__list>
<li class=sidebar__list-item>
<a href="https://arxiv.org/search/?searchtype=author&amp;query=Hatcher%2C+N" target=_blank rel="noopener me" aria-label=Publications title=Publications>
<i class="fas fa-file-alt fa-2x" aria-hidden=true></i>
</a>
</li>
<li class=sidebar__list-item>
<a href=https://github.com/nhatcher/ target=_blank rel="noopener me" aria-label=GitHub title=GitHub>
<i class="fab fa-github fa-2x" aria-hidden=true></i>
</a>
</li>
<li class=sidebar__list-item>
<a href=https://www.instagram.com/theuniverse.today target=_blank rel="noopener me" aria-label=instagram title=instagram>
<i class="fab fa-instagram fa-2x" aria-hidden=true></i>
</a>
</li>
<li class=sidebar__list-item>
<a href=mailto:nicolas@theuniverse.today target=_blank rel="noopener me" aria-label=e-mail title=e-mail>
<i class="fas fa-envelope fa-2x" aria-hidden=true></i>
</a>
</li>
</ul>
</div><footer class="footer footer__sidebar">
<ul class=footer__list>
<li class=footer__item>
&copy;
Nicolás Hatcher
2024
</li>
</ul>
</footer>
<script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></div>
</aside>
<main class=wrapper__main>
<header class=header><div class=.>
<a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
</a>
<nav class=nav>
<ul class=nav__list id=navMenu>
<li class=nav__list-item>
<a href=/ title>Home</a>
</li>
<li class=nav__list-item>
<a href=/post/ title>Posts</a>
</li>
<li class=nav__list-item>
<a href=/about/ title>About</a>
</li>
</ul>
<ul class="nav__list nav__list--end">
<li class=nav__list-item>
<div class=themeswitch>
<a title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i>
</a>
</div>
</li>
</ul>
</nav>
</div>
</header>
<div class="post
.">
<div class=post__content>
<h1>A Rustic Invitation to Parsing</h1>
<ul class=post__meta>
<li class=post__meta-item>
<em class="fas fa-calendar-day post__meta-icon"></em>
<span class=post__meta-text>
Thu, Apr 20, 2023
</span>
</li>
<li class=post__meta-item>
<em class="fas fa-stopwatch post__meta-icon"></em>
<span class=post__meta-text>15-minute read</span>
</li>
</ul>
<p>(A version of this post appeared first in the <a href=https://www.equalto.com/blog/a-rustic-invitation-to-parsing>EqualTo blog</a>)</p>
<p>Here we will show you how to build a simple parser. Keep reading to learn about algorithms, lexers, parsers and a little bit of Rust. And find all the code in our <a href=https://github.com/nhatcher/sample-desk-calcualtor>GitHub repository</a>.</p>
<h2 id=introduction-the-theory-of-parsing>Introduction. The theory of parsing</h2>
<p>At my previous company we built a spreadsheet engine from scratch in the Rust programming language. We can compile it to WebAssembly and run it in the browser or compile it to machine code and run it headless on the server. The first step in writing such an engine would be to write an Excel formula parser. Since writing a full fledged Excel formula parser is a daunting task we will split across multiple articles. In this first instalment today we will show you how to build a parser and interpreter for a desk calculator.</p>
<h3 id=parsing-essentials>Parsing essentials</h3>
<p>Parsing serves as the front end of a compiler and it is considered a solved problem today. Its primary purpose is to transform a human readable string into an object, the abstract syntax tree, that a computer can understand and process.</p>
<p>If you are creating a new programming language you will need to create a parser.</p>
<p>In general, there are two main approaches to parsing: you can either use a <em>parser generator</em> (also known as a &ldquo;compiler compiler&rdquo;) or create a <strong>handmade parser</strong> from scratch. Times have changed, and while 30 years ago the popular choice was the parser generator, today most folks would create a handmade parser from scratch.</p>
<p>Parser generators typically follow a bottom-up, non-recursive algorithm. They usually run in linear time and linear space, and are table-driven. The classic example is <a href=https://en.wikipedia.org/wiki/GNU_Bison>Bison</a>. There are many others, such as the famous <a href=https://www.antlr.org/>ANTLR</a>, which actually uses a top-down recursive algorithm. With these tools, you only need to specify the grammar for your language, and they will generate the code for your parser.</p>
<p>There are some disadvantages to parser generators:</p>
<ol>
<li>They introduce a dependency on the parser generator in your build system.</li>
<li>Since the generated code may not conform to your coding standards, you will likely need to treat it as an external dependency, further complicating your build process.</li>
<li>You&rsquo;ll probably have to make compromises on your grammar to make it compatible with the parser generator.</li>
</ol>
<p>Handmade parsers also have their drawbacks, as they&rsquo;re more susceptible than parser generators to errors and performance issues. Errors are more likely to occur in your code than in your grammar, although you can mitigate risks with thorough testing. On the other hand, it is easier to handle unusual corner cases in your language with a handwritten parser, which offers greater flexibility. Moreover, error reporting and recovery are much simpler with handwritten parsers.</p>
<p>In general, if you are writing a &ldquo;small&rdquo; language, I prefer a handmade parser. However, if you are working with a complex language, have time constraints, and have multiple contributors to the project, a parser generator might be the better option. These days, Bison is my parser generator of choice. <a href=https://en.wikipedia.org/wiki/Parsing_expression_grammar>PEG</a> is waiting in the wings, but is yet to take the crown.</p>
<p>One final thing about handmade parsers&mldr; they are a lot of fun! :)</p>
<p>In this next section we will build a calculator using a Pratt parser. There is a fair amount of theory involved, so if some aspects are unclear upon first reading, continue reading and return to those parts later for clarification.</p>
<h2 id=a-desk-calculator>A desk calculator</h2>
<blockquote>
<p>What I cannot create, I do not understand</p>
<p>Richard Feynman</p>
</blockquote>
<p>In their now almost 40 year old book <a href=https://en.wikipedia.org/wiki/The_Unix_Programming_Environment>The Unix Programming Environment</a> Brian Kernighan and Rob Pike urge us to build a desk calculator. They used the standard techniques at the time, a parser generator <em>yacc</em> (predecessor to Bison) and <em>lex</em> (today you could use flex).</p>
<p>We are going to follow in their footsteps, and create a handmade parser for a desk calculator.</p>
<p>You can find all the code for this example in our <a href=https://github.com/nhatcher/sample-desk-calcualtor>GitHub repository</a>.</p>
<h3 id=the-one-with-the-repl>The one with the REPL</h3>
<p>First thing we need is a <em>REPL</em> (Read-Eval-Print-Loop). Go ahead create a new Rust project with <code>cargo new calculator</code> and substitute the <code>main.rs</code> file with:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>io</span>::<span class=p>{</span><span class=n>stdin</span><span class=p>,</span><span class=w> </span><span class=n>stdout</span><span class=p>,</span><span class=w> </span><span class=n>Write</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>evaluate</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>String</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>input</span><span class=p>.</span><span class=n>to_string</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>print!</span><span class=p>(</span><span class=s>&#34;Input: &#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>stdout</span><span class=p>().</span><span class=n>flush</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>stdin</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>read_line</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>input</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=s>&#34;Failed reading command&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>input</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>input</span><span class=p>.</span><span class=n>trim</span><span class=p>().</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;.exit&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Bye!&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=o>&amp;</span><span class=n>input</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Output: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>output</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>That is an echo REPL, it responds to user input by printing their input back to them (hence &ldquo;echo&rdquo;). You can run your program with <code>cargo run</code>. If you type <code>.exit</code> you exit the program.</p>
<h3 id=the-one-with-the-grammar>The one with the grammar</h3>
<p>We are going to split the evaluate function in two parts:</p>
<ol>
<li><strong>Parse:</strong> parsing the formula into an <em><a href=https://en.wikipedia.org/wiki/Abstract_syntax_tree>abstract syntax tree</a></em> (or AST for short)</li>
<li><strong>Evaluate:</strong> traversing the parse tree in order to evaluate. The second part is the job of an <em>interpreter</em>.</li>
</ol>
<p>When writing a parser the first thing you need to do is to spell out the grammar for your language:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>expression    =&gt; primary operator expression | primary
</span></span><span class=line><span class=cl>primary       =&gt; Number | Variable_name | &#39;(&#39; expression &#39;)&#39; | function_call
</span></span><span class=line><span class=cl>function_call =&gt; Function_name &#39;(&#39; expr &#39;)&#39;
</span></span><span class=line><span class=cl>operator      =&gt; &#39;+&#39; | &#39;-&#39; | &#39;*&#39; | &#39;/&#39;
</span></span></code></pre></div><p>These are the blueprints of the program we are going to write. There are formal, very theoretical specifications of what a grammar is, but we will be a bit loose here.</p>
<h3 id=the-one-with-the-lexer>The one with the lexer</h3>
<p>A lexer is an algorithm that processes an input string and provides a list of indivisible atoms in the language, known as <em>tokens</em>. Some tokens consist of a single character, such as <code>(</code> or the plus operator <code>+</code>, while others are composed of multiple characters, like the function name <code>Sin</code> or a number like <code>2.3e-12</code>.</p>
<p>Once your grammar is defined, you should create your data structures. Rust is very convenient for this, due to the availability of <em><a href=https://en.wikipedia.org/wiki/Algebraic_data_type>algebraic data types</a></em> and <em>enum varieties</em>.</p>
<p>The list of tokens will be an <em>enum</em>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Tokens
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Number</span><span class=p>(</span><span class=kt>f64</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Name</span><span class=p>(</span><span class=nb>String</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>OpenParenthesis</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>CloseParenthesis</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Plus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Minus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Times</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Divide</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The lexer (also known as a scanner or tokenizer), will get a string like <code>"2.3+4*(Sin(3+7)+5)^2"</code> and return one by one its components or <em>tokens</em>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[
</span></span><span class=line><span class=cl>    Number(2.3),
</span></span><span class=line><span class=cl>    Plus,
</span></span><span class=line><span class=cl>    Number(4.0),
</span></span><span class=line><span class=cl>    Times,
</span></span><span class=line><span class=cl>    OpenParenthesis,
</span></span><span class=line><span class=cl>    Name(&#34;Sin&#34;),
</span></span><span class=line><span class=cl>    OpenParenthesis,
</span></span><span class=line><span class=cl>    Number(3.0),
</span></span><span class=line><span class=cl>    Plus,
</span></span><span class=line><span class=cl>    Number(7.0),
</span></span><span class=line><span class=cl>    CloseParenthesis,
</span></span><span class=line><span class=cl>    Plus,
</span></span><span class=line><span class=cl>    Number(5.0),
</span></span><span class=line><span class=cl>    Power, 
</span></span><span class=line><span class=cl>    Number(2.0)
</span></span><span class=line><span class=cl>]
</span></span></code></pre></div><p>The algorithm that performs this task is a <a href=https://en.wikipedia.org/wiki/Deterministic_finite_automaton>Deterministic Finite Automaton</a> (DFA). Essentially, if your tokens can be described by Regular Expressions (RE), they can be converted to a DFA and easily implemented in code (as per <a href=https://en.wikipedia.org/wiki/Thompson%27s_construction>Thompson&rsquo;s construction</a>). In this article, we will not delve into the theorem itself; instead, we will focus on how we can apply it to our specific example.</p>
<p>Outline of the desk calculator lexer:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Lexer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>input_chars</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>position</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Lexer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>new</span><span class=p>(</span><span class=n>input_text</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Lexer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>input_chars</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>input_text</span><span class=p>.</span><span class=n>chars</span><span class=p>().</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Lexer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>input_chars</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>position</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>next_token</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>consume_whitespace</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>read_next_char</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=n>ch</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>ch</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=sc>&#39;+&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Plus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=sc>&#39;-&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Minus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=sc>&#39;*&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Times</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=sc>&#39;/&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Divide</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=sc>&#39;^&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Power</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=sc>&#39;(&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>OpenParenthesis</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=sc>&#39;)&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>CloseParenthesis</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=sc>&#39;0&#39;</span><span class=o>..=</span><span class=sc>&#39;9&#39;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;.&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=w> </span><span class=o>-=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=bp>self</span><span class=p>.</span><span class=n>read_number</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=sc>&#39;A&#39;</span><span class=o>..=</span><span class=sc>&#39;Z&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>read_function</span><span class=p>(</span><span class=n>ch</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>Illegal</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;Unexpected character: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>ch</span><span class=p>)),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Token</span>::<span class=n>EoI</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>read_next_char</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>next_char</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>input_chars</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>next_char</span><span class=p>.</span><span class=n>is_some</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>next_char</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>peek_char</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>input_chars</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>consume_whitespace</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>input_chars</span><span class=p>.</span><span class=n>get</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=kt>char</span><span class=p>.</span><span class=n>is_whitespace</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>read_function_name</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>first_letter</span>: <span class=kt>char</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>todo!</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>read_number</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>todo!</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Let&rsquo;s review. First, observe the Lexer definition:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Lexer</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>input_chars</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>position</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>If we were to make the same structure in TypeScript, Python, Kotlin, &mldr; the definition would be obvious:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>Lexer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>input</span><span class=p>:</span> <span class=n>String</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>var</span> <span class=py>position</span><span class=p>:</span> <span class=n>UInt</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>)</span> <span class=p>{</span> <span class=cm>/*...*/</span> <span class=p>}</span>
</span></span></code></pre></div><p>But in Rust we have many things to consider. Do we want the data to be owned by the Lexer, or is the data shared? The first option is easier but implies that the Lexer will make a copy of the data and do memory allocations on the heap. The second is a bit more complex because it involves lifetimes, but it&rsquo;s faster and more memory efficient.</p>
<p>But the questions do not end there. You might want to use a <em><a href=https://doc.rust-lang.org/book/ch15-00-smart-pointers.html>smart pointer</a></em> such as a <code>Box&lt;Node></code>, if you just want to store the pointer in the stack. We will use that when we discuss the parser. The <em>abstract syntax tree</em> is an acyclic graph, but if we were to deal with a cyclic graph then you&rsquo;d probably need to use an <code>Rc&lt;Node></code>.</p>
<p>Also, notice how we convert the <code>String</code> to a vector of <code>char</code>. Rust has a <code>String</code> type, but it is simply a vector of bytes encoding a UTF-8 string, which complicates accessing individual characters (due to multibyte encodings).</p>
<p>Most of the code in the lexer should be relatively straightforward to read, with the possible exception of the &ldquo;number recognizer&rdquo;.</p>
<p>It&rsquo;s surprisingly difficult to parse numbers. As recently as November 2022, <a href=https://lemire.me/en/>Daniel Lemire</a> demonstrated that it is possible to <a href=https://lemire.me/blog/2021/01/29/number-parsing-at-a-gigabyte-per-second/>parse numbers at gigabytes per second</a>. Number parsing has two steps:</p>
<ol>
<li><em>Recognizing</em> the number by identifying the integer part, decimal part, and exponent.</li>
<li><em>Finding</em> the closest floating-point number to the real number we recognized.</li>
</ol>
<p>The second step is the more difficult of the two.</p>
<p>The inverse problem of finding the most visually appealing way to display a given floating-point number currently relies on the <a href=https://github.com/ulfjack/ryu>Ryū algorithm</a> by <a href="https://www.youtube.com/watch?v=kw-U6smcLzk&amp;ab_channel=PLDI2018">Ulf Adams</a>, which is one of my favorite <em>modern</em> algorithms.</p>
<p>A RE for a number might be:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/^[+-]?[0-9]+(.[0-9]+)?([Ee][+-][0-9]+)?$/
</span></span></code></pre></div><p>Consider this diagram (<em>accepting states</em> are 3, 5 and 8):</p>
<p><img src=/images/parse.png alt=Diagram></p>
<p>Our number recognizer, a <em>finite automata</em>, has 8 states. An &ldquo;accepting state&rdquo; is a state in which you can finish your parsing. It&rsquo;s pretty easy to transform the above diagram into code:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>read_number</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=kt>str</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>.</span><span class=n>to_string</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>accept</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=n>accept</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>peek_char</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>match</span><span class=w> </span><span class=n>state</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>State1</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;-&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;+&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State2</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>return</span><span class=w> </span><span class=n>Token</span>::<span class=n>Illegal</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;Expecting digit or + or -, got </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>State2</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>return</span><span class=w> </span><span class=n>Token</span>::<span class=n>Illegal</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;Expecting digit got  </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>State3</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=c1>// Accepting state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;.&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State4</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;E&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;e&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State6</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>accept</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>State4</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State5</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>return</span><span class=w> </span><span class=n>Token</span>::<span class=n>Illegal</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;Expecting digit got  </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>State5</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=c1>// Accepting state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;e&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;E&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State6</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>accept</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>State6</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;+&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;-&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State7</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>return</span><span class=w> </span><span class=n>Token</span>::<span class=n>Illegal</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;Expecting &#39;+&#39;or &#39;-&#39; got  </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>State7</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>State8</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=k>return</span><span class=w> </span><span class=n>Token</span>::<span class=n>Illegal</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;Expecting digit got  </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>c</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>State8</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=c1>// Accepting state
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                        </span><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=n>c</span><span class=p>.</span><span class=n>is_ascii_digit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>accept</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>accept</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=kt>str</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>c</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Token</span>::<span class=n>Number</span><span class=p>(</span><span class=kt>str</span><span class=p>.</span><span class=n>parse</span>::<span class=o>&lt;</span><span class=kt>f64</span><span class=o>&gt;</span><span class=p>().</span><span class=n>unwrap</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=the-one-with-the-parser>The one with the parser</h3>
<blockquote>
<p>To iterate is human, to recurse divine.</p>
<p>Peter Deutsch</p>
</blockquote>
<p>Once we are able to lex tokens we are ready to build the AST. We will use a top down recursive parser.
The data structure is something like:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Abstract syntax tree nodes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>enum</span> <span class=nc>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Operation</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>op</span>: <span class=nc>Operation</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>left</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=nb>None</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>right</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Function</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>fun</span>: <span class=nc>Function</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>arg</span>: <span class=nb>Box</span><span class=o>&lt;</span><span class=n>Node</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Number</span><span class=p>(</span><span class=kt>f64</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Variable</span><span class=p>(</span><span class=nb>String</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>enum</span> <span class=nc>Function</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Sin</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Cos</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Tan</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Ln</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Exp</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>enum</span> <span class=nc>Operator</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Plus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Minus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Times</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Divide</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Note that in Rust we use a smart pointer (<code>Box</code>) to link to the next node in a tree structure.</p>
<p>Although we are building a simple calculator we are actually going to face one of the most difficult problems in parsing: left recursion and precedence.</p>
<p>The correct parse tree for the formula <code>3+4*8</code> is:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>     +
</span></span><span class=line><span class=cl>    / \
</span></span><span class=line><span class=cl>   3   *
</span></span><span class=line><span class=cl>      / \
</span></span><span class=line><span class=cl>     4   8
</span></span></code></pre></div><p>And not:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>     *
</span></span><span class=line><span class=cl>    / \
</span></span><span class=line><span class=cl>   +   8
</span></span><span class=line><span class=cl>  / \
</span></span><span class=line><span class=cl> 3   4
</span></span></code></pre></div><p>The latter parse tree describes <code>(3+4)*8</code>, not <code>3+4*8</code>. That is to say: <code>*</code> has precedence over <code>+</code>.</p>
<p>Traditionally, grammar is adapted to reflect the precedence rules so as to produce the desired parse tree. But we will follow a different strategy: &ldquo;top down precedence parsing&rdquo; was invented by <a href=https://tdop.github.io/>Vaughan Pratt</a> and popularized in his build of jslint by <a href=https://crockford.com/javascript/tdop/tdop.html>Douglas Crockfort</a> and <a href=https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/>Bob Nystrom</a> of <a href=http://gameprogrammingpatterns.com/>Game programming patterns</a> and <a href=http://craftinginterpreters.com/>Crafting interpreters</a> fame, and must be one of the most beautiful recursive parsing algorithms ever written.</p>
<p>Here we are inspired by the work of <a href=https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html>Alex Kladov</a> in implementing a Pratt parser.</p>
<p>The central idea is to attach some <em>binding powers</em> to each operator. <code>*</code> will have a higher binding power than <code>+</code>, for instance.</p>
<p>The basic implementation of a top down recursive Pratt parser will therefore resemble:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Parser</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lexer</span>: <span class=nc>Lexer</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>infix_binding_power</span><span class=p>(</span><span class=n>op</span>: <span class=kp>&amp;</span><span class=nc>Operator</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>u8</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Operator</span>::<span class=n>Plus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Operator</span>::<span class=n>Minus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Operator</span>::<span class=n>Times</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Operator</span>::<span class=n>Divide</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>3</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Operator</span>::<span class=n>Power</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Parser</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=n>input_text</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>Node</span><span class=p>,</span><span class=w> </span><span class=n>ParserError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>lexer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Lexer</span>::<span class=n>new</span><span class=p>(</span><span class=n>input_text</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>parser</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Parser</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lexer</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>parser</span><span class=p>.</span><span class=n>parse_expression</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_expression</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>left_bp</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>Node</span><span class=p>,</span><span class=w> </span><span class=n>ParserError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>lhs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>parse_primary</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>next_token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>EoI</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>break</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>CloseParenthesis</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>break</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>Plus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Operator</span>::<span class=n>Plus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>Minus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Operator</span>::<span class=n>Minus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>Times</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Operator</span>::<span class=n>Times</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>Divide</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Operator</span>::<span class=n>Divide</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>Power</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Operator</span>::<span class=n>Power</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>unexpected</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>todo!</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>right_bp</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>binding_power</span><span class=p>(</span><span class=o>&amp;</span><span class=n>op</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>right_bp</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>left_bp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>rhs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>parse_expression</span><span class=p>(</span><span class=n>right_bp</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>lhs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Node</span>::<span class=n>BinaryOp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>op</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>left</span>: <span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>lhs</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>right</span>: <span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>rhs</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>lhs</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>parse_primary</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>Node</span><span class=p>,</span><span class=w> </span><span class=n>ParserError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>lexer</span><span class=p>.</span><span class=n>next_token</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Token</span>::<span class=n>Number</span><span class=p>(</span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nb>Ok</span><span class=p>(</span><span class=n>Node</span>::<span class=n>Number</span><span class=p>(</span><span class=n>value</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Token</span>::<span class=n>Plus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>primary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>parse_primary</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nb>Ok</span><span class=p>(</span><span class=n>Node</span>::<span class=n>UnaryOp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>op</span>: <span class=nc>UnaryOperator</span>::<span class=n>Plus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>right</span>: <span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>primary</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Token</span>::<span class=n>Minus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>primary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>parse_primary</span><span class=p>()</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nb>Ok</span><span class=p>(</span><span class=n>Node</span>::<span class=n>UnaryOp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>op</span>: <span class=nc>UnaryOperator</span>::<span class=n>Minus</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>right</span>: <span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>primary</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Token</span>::<span class=n>Name</span><span class=p>(</span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>lexer</span><span class=p>.</span><span class=n>next_token</span><span class=p>()</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>Token</span>::<span class=n>OpenParenthesis</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>return</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>Node</span>::<span class=n>Variable</span><span class=p>(</span><span class=n>name</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>argument</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>parse_expression</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=n>Token</span>::<span class=n>CloseParenthesis</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>name</span><span class=p>.</span><span class=n>as_str</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=s>&#34;Cos&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Function</span>::<span class=n>Cos</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=s>&#34;Sin&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Function</span>::<span class=n>Sin</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=s>&#34;Tan&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Function</span>::<span class=n>Tan</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=s>&#34;Log&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Function</span>::<span class=n>Log</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=s>&#34;Exp&#34;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>Function</span>::<span class=n>Exp</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>ParserError</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>position</span>: <span class=nc>self</span><span class=p>.</span><span class=n>lexer</span><span class=p>.</span><span class=n>get_position</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                            </span><span class=n>message</span>: <span class=nc>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Invalid function name: &#39;{}&#39;&#34;</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nb>Ok</span><span class=p>(</span><span class=n>Node</span>::<span class=n>Function</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>index</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>arg</span>: <span class=nb>Box</span>::<span class=n>new</span><span class=p>(</span><span class=n>argument</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Token</span>::<span class=n>OpenParenthesis</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>primary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>parse_expression</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>expect</span><span class=p>(</span><span class=n>Token</span>::<span class=n>CloseParenthesis</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nb>Ok</span><span class=p>(</span><span class=n>primary</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Token</span>::<span class=n>CloseParenthesis</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Token</span>::<span class=n>Times</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>Token</span>::<span class=n>Divide</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>ParserError</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>position</span>: <span class=nc>self</span><span class=p>.</span><span class=n>lexer</span><span class=p>.</span><span class=n>get_position</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>message</span>: <span class=nc>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Unexpected token: &#39;{value}&#39;&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>You will probably remember from your school days that every recursive algorithm has an equivalent iterative algorithm. In this particular case the iterative algorithm is called <em><a href=https://en.wikipedia.org/wiki/Shunting_yard_algorithm>shunting yard algorithm</a></em> and was invented by Edsger Dijkstra 1961 for the Algol programming language.</p>
<p>The first part, the <code>parse_expression</code> part is the top down precedence parser, the <code>parse_primary</code> is just a standard top down recursive parser that mimics the grammar that we repeat here because it is that important:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>expression</span>    <span class=o>=&gt;</span> <span class=n>primary</span> <span class=n>operator</span> <span class=n>expression</span> <span class=o>|</span> <span class=n>primary</span>
</span></span><span class=line><span class=cl><span class=n>primary</span>       <span class=o>=&gt;</span> <span class=n>number</span> <span class=o>|</span> <span class=n>variable_name</span> <span class=o>|</span> <span class=s1>&#39;(&#39;</span> <span class=n>expression</span> <span class=s1>&#39;)&#39;</span> <span class=o>|</span> <span class=n>function_call</span>
</span></span><span class=line><span class=cl><span class=n>function_call</span> <span class=o>=&gt;</span> <span class=n>function_name</span> <span class=s1>&#39;(&#39;</span> <span class=n>expr</span> <span class=s1>&#39;)&#39;</span>
</span></span><span class=line><span class=cl><span class=n>operator</span>      <span class=o>=&gt;</span> <span class=s1>&#39;+&#39;</span> <span class=o>|</span> <span class=s1>&#39;-&#39;</span> <span class=o>|</span> <span class=s1>&#39;*&#39;</span> <span class=o>|</span> <span class=s1>&#39;/&#39;</span>
</span></span></code></pre></div><p>Note that the most difficult part is to tell apart a function call from a variable name. The way to do that is to realize that a function call must have a <code>(</code> after the name. This sort of thing is what is relatively easy in a handmaid parser, but awkward in a parser generator.</p>
<h3 id=the-one-with-the-walking-interpreter>The one with the walking interpreter</h3>
<p>Although not the focus for this post, a calculator would be incomplete without an evaluator. It is the soul of a tree walking interpreter.</p>
<p>Once we have the AST, evaluation is pretty straightforward:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>evaluate</span><span class=p>(</span><span class=n>input</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=n>ParserError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Parser</span>::<span class=n>parse</span><span class=p>(</span><span class=n>input</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>evaluate_node</span><span class=p>(</span><span class=o>&amp;</span><span class=n>node</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>evaluate_node</span><span class=p>(</span><span class=n>node</span>: <span class=kp>&amp;</span><span class=nc>Node</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=n>ParserError</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span>::<span class=n>Number</span><span class=p>(</span><span class=n>f</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=o>*</span><span class=n>f</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span>::<span class=n>Variable</span><span class=p>(</span><span class=n>s</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=s>&#34;PI&#34;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nb>Ok</span><span class=p>(</span><span class=n>std</span>::<span class=kt>f64</span>::<span class=n>consts</span>::<span class=no>PI</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nb>Err</span><span class=p>(</span><span class=n>ParserError</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>position</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>message</span>: <span class=nc>format</span><span class=o>!</span><span class=p>(</span><span class=s>&#34;Unknown constant: {s}&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span>::<span class=n>Function</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>index</span><span class=p>,</span><span class=w> </span><span class=n>arg</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>argument</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>evaluate_node</span><span class=p>(</span><span class=n>arg</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>match</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Function</span>::<span class=n>Cos</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>argument</span><span class=p>.</span><span class=n>cos</span><span class=p>()),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Function</span>::<span class=n>Sin</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>argument</span><span class=p>.</span><span class=n>sin</span><span class=p>()),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Function</span>::<span class=n>Tan</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>argument</span><span class=p>.</span><span class=n>tan</span><span class=p>()),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Function</span>::<span class=n>Log</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>argument</span><span class=p>.</span><span class=n>ln</span><span class=p>()),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Function</span>::<span class=n>Exp</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>argument</span><span class=p>.</span><span class=n>exp</span><span class=p>()),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span>::<span class=n>BinaryOp</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>op</span><span class=p>,</span><span class=w> </span><span class=n>left</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>lhs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>evaluate_node</span><span class=p>(</span><span class=n>left</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>rhs</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>evaluate_node</span><span class=p>(</span><span class=n>right</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>match</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Operator</span>::<span class=n>Plus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>lhs</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>rhs</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Operator</span>::<span class=n>Minus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>lhs</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>rhs</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Operator</span>::<span class=n>Times</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>lhs</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>rhs</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Missing error handling
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=n>Operator</span>::<span class=n>Divide</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>lhs</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=n>rhs</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Operator</span>::<span class=n>Power</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>lhs</span><span class=p>.</span><span class=n>powf</span><span class=p>(</span><span class=n>rhs</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Node</span>::<span class=n>UnaryOp</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>op</span><span class=p>,</span><span class=w> </span><span class=n>right</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>op</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>UnaryOperator</span>::<span class=n>Plus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>evaluate_node</span><span class=p>(</span><span class=n>right</span><span class=p>)</span><span class=o>?</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>UnaryOperator</span>::<span class=n>Minus</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=o>-</span><span class=n>evaluate_node</span><span class=p>(</span><span class=n>right</span><span class=p>)</span><span class=o>?</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=the-one-with-the-exercises>The one with the exercises</h3>
<ol>
<li>(easy) Add more functions to the calculator.</li>
<li>(medium) Add a <code>Sum</code> function with three arguments like <code>Sum(1, 100, n*n)</code> or <code>Sum(n*n, {n, 1, 100})</code> depending on your taste.</li>
<li>(medium) Add variables <code>a = 7.4</code> or <code>a = 4*Sin(3)</code> that you can use in later expressions. You will need to maintain a symbol table</li>
<li>(difficult) Add for loops and if branches and create your first mini language!</li>
<li>(difficult) Rewrite the parser using Dijkstra&rsquo;s shunting yard algorithm.</li>
</ol>
<h2 id=general-references>General references</h2>
<p>If you want a simple and direct account of many of the issues discussed here, I cannot recommend this book enough:</p>
<ul>
<li><a href=https://www3.nd.edu/~dthain/compilerbook/>Introduction to Compilers and Language Design</a> by Douglas Thain</li>
</ul>
<p>Thorsten Ball has written a really nice book very much in the same spirit as this post:</p>
<ul>
<li><a href=https://interpreterbook.com/>Writing an interpreter in go</a></li>
</ul>
<p>Robert Nystrom&rsquo;s book is freely available and is a thing of beauty:</p>
<ul>
<li><a href=https://craftinginterpreters.com/>Crafting interpreters</a></li>
</ul>
<p>Also worth mentioning:</p>
<ul>
<li><a href=https://buildyourownlisp.com/>Build your own Lisp</a></li>
</ul>
<p>A couple of more academic references:</p>
<ul>
<li><a href=https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-815412-0>Engineering a compiler</a> by Keith Cooper and Linda Torczon</li>
<li><a href=https://www.pearson.ch/HigherEducation/Pearson/EAN/9780136067054/Crafting-A-Compiler>Crafting a compiler</a> by Charles N. Fischer, Ron K. Cytron and Richard J. LeBlanc</li>
</ul>
<p>The dragon book will always remain a classic in the subject:</p>
<ul>
<li><a href=https://suif.stanford.edu/dragonbook/>Compilers: Principles, Techniques, and Tools</a></li>
</ul>
<p>If you are up for a MOOC, I can recommend this course describing the COOL programming language by Alex Aiken</p>
<ul>
<li><a href=https://www.edx.org/course/compilers>Compilers</a></li>
</ul>
<p>Or the course by Jeffrey Ullman (one of the authors of the dragon book). This might be a bit advanced.</p>
<ul>
<li><a href=https://www.edx.org/course/automata-theory>Automata theory</a></li>
</ul>
<p>Both courses from Stanford University</p>
</div>
<div class=post__footer>
</div>
<div id=comment>
<h2>comments</h2>
<script src=https://utteranc.es/client.js repo=nhatcher/nhatcher.github.io issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script>
</div>
</div>
</main>
</div><footer class="footer footer__base">
<ul class=footer__list>
<li class=footer__item>
&copy;
Nicolás Hatcher
2024
</li>
</ul>
</footer>
<script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script></body>
</html>